<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>NSBImplementation</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script> <script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>


<p class="NDLRefHeadClassTitle">NSBImplementation</p>

<p class="NDLRefParentage">: public <a href="../../Reference/NiSystem/NiMemObject.htm"><span>NiMemObject</span></a></p>

<p class="NDLRefHeaderFile">&lt;NSBImplementation.h&gt;</p>

<p class="NDLRefHead1">Description</p>

<p><span class="NDLSystemFont">NSBImplementation</span> 
 represents a specific implementation of a shader in the Gamebryo engine. 
 Implementations are used in shaders to allow for supplying alternative 
 approaches to achieving the same rendering effect. For example, a shader 
 could supply two implementations of a technique, one that utilizes shader 
 programs for the latest hardware, and one that doesn't to allow for supporting 
 older hardware.</p>

<p class="NDLRefHead1">Constructors</p>

<p class="NDLRefMemberFunction">NSBImplementation()</p>

<p class="NDLRefMemberDescription">The constructor for <span class="NDLSystemFont">NSBImplementation</span> creates 
 an 'empty' instance.</p>

<p class="NDLRefHead1">Supported Member Functions</p>

<p class="NDLRefMemberFunction">const char* GetName()</p>

<p class="NDLRefMemberDescription">Returns the name of the implementation. 
 Used for tools to identify different implementations.</p>

<p class="NDLRefMemberFunction">void SetName(const char* pcName)</p>

<p class="NDLRefMemberDescription">Sets the name of the implementation.</p>

<p class="NDLRefMemberFunction">const char* GetDesc()</p>

<p class="NDLRefMemberDescription">Returns the description of the implementation. 
 Used for tools to describe the different implementations.</p>

<p class="NDLRefMemberFunction">void SetDesc(const char* pcDesc)</p>

<p class="NDLRefMemberDescription">Sets the description of the implementation.</p>

<p class="NDLRefMemberFunction">const char* GetClassName()</p>

<p class="NDLRefMemberDescription">Gets the user-defined class name.</p>

<p class="NDLRefMemberFunction">void SetClassName(const char* pcClassName)</p>

<p class="NDLRefMemberDescription">Sets the user-defined class name.</p>

<p class="NDLRefMemberFunction"><a HREF="NSBRequirements.htm">NSBRequirements</a>* 
 GetRequirements()</p>

<p class="NDLRefMemberDescription">Retrieves the requirements for the implementation.</p>

<p class="NDLRefMemberFunction">const char* GetPackingDef()</p>

<p class="NDLRefMemberDescription">Retrieves the name of the packing definition 
 the implementation requires. This definition must be one of the packing 
 definitions in the shader's packing definition map.</p>

<p class="NDLRefMemberFunction">void SetPackingDef(const char* pcPackingDef)</p>

<p class="NDLRefMemberDescription">Sets the name of the packing definition 
 the implementation requires.</p>

<p class="NDLRefMemberFunction"><a HREF="NSBStateGroup.htm">NSBStateGroup</a>* 
 GetRenderStateGroup()</p>

<p class="NDLRefMemberDescription">Retrieves the 'global' render state group 
 for the implementation.</p>

<p class="NDLRefMemberFunction">unsigned int GetVertexConstantMapCount()</p>

<p class="NDLRefMemberDescription">Returns the number of vertex constant 
 maps for the implementation.</p>

<p class="NDLRefMemberFunction">unsigned int GetGeometryConstantMapCount()</p>

<p class="NDLRefMemberDescription">Returns the number of geometry constant 
 maps for the implementation.</p>

<p class="NDLRefMemberFunction">unsigned int GetPixelConstantMapCount()</p>

<p class="NDLRefMemberDescription">Returns the number of pixel constant maps 
 for the implementation.</p>

<p class="NDLRefMemberFunction"><a HREF="NSBConstantMap.htm">NSBConstantMap</a>* 
 GetVertexConstantMap(unsigned int uiIndex)</p>

<p class="NDLRefMemberDescription">Retrieves the 'global' vertex shader constant 
 map with the given index for the implementation.</p>

<p class="NDLRefMemberFunction"><a href="NSBConstantMap.htm">NSBConstantMap</a>* 
 GetGeometryConstantMap(unsigned int uiIndex)</p>

<p class="NDLRefMemberDescription">Retrieves the 'global' geometry shader 
 constant map with the given index for the implementation.</p>

<p class="NDLRefMemberFunction"><a HREF="NSBConstantMap.htm">NSBConstantMap</a>* 
 GetPixelConstantMap(unsigned int uiIndex)</p>

<p class="NDLRefMemberDescription">Retrieves the 'global' pixel shader constant 
 map with the given index for the implementation.</p>
 
<p class="NDLRefMemberFunction">unsigned int GetConstantMapCount(<a href="../../Reference/NiMain/NiGPUProgram.htm#ProgramType">NiGPUProgram::ProgramType</a> eType)</p>

<p class="NDLRefMemberDescription">Retrieves the number of 'global' constant 
 maps for the given shader type.</p>

 <p class="NDLRefMemberFunction"><a HREF="NSBConstantMap.htm">NSBConstantMap</a>* 
 GetConstantMap(<a href="../../Reference/NiMain/NiGPUProgram.htm#ProgramType">NiGPUProgram::ProgramType</a> eType, unsigned int uiIndex)</p>

<p class="NDLRefMemberDescription">Retrieves the 'global' pixel shader constant 
 map with the given shader type and index for the implementation.</p>

 <p class="NDLRefMemberFunction">unsigned int AddConstantMap(<a href="../../Reference/NiMain/NiGPUProgram.htm#ProgramType">NiGPUProgram::ProgramType</a> eType)</p>

<p class="NDLRefMemberDescription">Creates a new 'global' constant map for the given shader type.</p>

<p class="NDLRefMemberFunction">unsigned int GetPassCount()</p>

<p class="NDLRefMemberDescription">Retrieves the number of passes in the 
 implementation.</p>

<p class="NDLRefMemberFunction"><a HREF="NSBPass.htm">NSBPass</a>* GetPass(unsigned 
 int uiIndex, bool bCreate = true)</p>

<p class="NDLRefMemberDescription">Retrieve the pass at the given index. 
 If <span class="NDLSystemFont">bCreate</span> is <span class="NDLSystemFont">true</span>, 
 and no pass exists at that index, a pass instance is created, inserted 
 in the pass array, and returned. If <span class="NDLSystemFont">bCreate</span> 
 is <span class="NDLSystemFont">false</span> and no pass 
 exists at that index, <span class="NDLSystemFont">NULL</span> 
 is returned.</p>

<p class="NDLRefMemberFunction"><a HREF="NSBUserDefinedDataSet.htm">NSBUserDefinedDataSet</a>* 
 GetUserDefinedDataSet()</p>

<p class="NDLRefMemberFunction">void SetUserDefinedDataSet(<a HREF="NSBUserDefinedDataSet.htm">NSBUserDefinedDataSet</a>* 
 pkUDDSet)</p>

<p class="NDLRefMemberDescription">Get and set the user defined data set 
for this implementation.</p>

<p class="NDLRefMemberFunction">const NiSemanticAdapterTable&amp; GetSemanticAdapterTable() const</p>

<p class="NDLRefMemberFunction">NiSemanticAdapterTable&amp; GetSemanticAdapterTable()</p>

<p class="NDLRefMemberDescription">Gets the <span class="NDLSystemFont"><a href="../../Reference/NiMain/NiSemanticAdapterTable.htm">NiSemanticAdapterTable</a></span> associated with this implementation.</p>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>
