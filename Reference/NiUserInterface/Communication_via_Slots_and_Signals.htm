<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>Communication via Slots and Signals</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2"
type="text/javascript">
</script><script language="JavaScript1.2" type="text/javascript">
WriteNavLink(2);
</script>

<h1>Communication via Slots and Signals</h1>

<p>When creating a UI system, communication between UI elements
and application programmer's code must be resolved. Several
systems exist which resolve this problem with varying results
(speed vs. code simplicity, etc.). The <span class=
"NDLSystemFont">NiUserInterface</span> library employs the well
known "Slots and Signals" system due to its relative speed and
easy programming interface.</p>

<p>The principle behind slots and signals is that the message
sending code (the signal) need not know if zero, one, or many
objects are listening. Nor does receiving code (the slot) need to
know who sent the message, or how many pieces of code may send
him a signal. Each slot maintains a pointer to a single callback
function. When it receives a signal with some data, it forwards
that data to the callback function. This alone simplifies much of
the application programmer's time requirements when communicating
between elements.</p>

<p>A principal benefit of slots and signals is that when they are
properly used, invalid callback functions can be completely
avoided. By making a slot a member of the class which owns the
callback function and properly initializing the slot in the
object constructor, the life of the slot is identical to the life
of the callback function owner. On deletion, a slot removes
itself from all signals to which it is subscribed. Signals behave
similarly. Thus, objects can emit signals freely without concern
for whether a callback function is still valid or has been
deleted.</p>

<p>In order to make our slot and signal implementations as widely
effective as possible, Gamebryo's slot and signal implementation
is templatized to allow communication of different data types.
This makes it so that connections created between slots and
signals of different message types fail at compile time instead
of causing strange logic errors during run time (as happens with
void* parameter passing).</p>

<p>For an example of the use of signals, examine <span class=
"NDLSystemFont">NiUIBaseElement</span>. Also, the <span class=
"NDLSystemFont">NiUIManager</span> owns several slots and
signals.</p>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>
