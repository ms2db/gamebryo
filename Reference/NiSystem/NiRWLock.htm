<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>NiRWLock</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2"
type="text/javascript">
</script><script language="JavaScript1.2" type="text/javascript">
WriteNavLink(2);
</script>

<p class="NDLRefHeadClassTitle">NiRWLock</p>

<p class="NDLRefHeaderFile">&lt;NiRWLock.h&gt;</p>

<p class="NDLRefHead1">Description</p>

<p>A platform-independent wrapper class to handle reader-writer
locks for threading. Multiple reader threads are allowed to enter
the block provided that no thread is currently writing.
Similarly, locking for write will wait for all readers to exit
before entering.</p>

<p>Note that reader-writer locks have higher overhead for lock
acquisition than a simple critical section if the lock is
uncontested. They should be used by applications only for heavily
contested locks when multiple simultaneous threads are reading
and writing is less frequent.</p>

<p class="NDLRefHead1">Constructors</p>

<p class="NDLRefMemberFunction">NiRWLock()</p>

<p class="NDLRefMemberDescription">Default constructor. The lock
is initialized to an unlocked state.</p>

<p class="NDLRefHead1">Supported Member Functions</p>

<p class="NDLRefMemberFunction">void LockRead()</p>

<p class="NDLRefMemberDescription">Acquire the lock for read
access. If another thread has acquired the lock for write access,
this call will block until the lock is free. If other threads
have acquired the lock for read access, this call will not block.
Calls to <span class="NDLSystemFont">LockRead</span> may be
nested, but they must be matched by an equal number of calls to
<span class="NDLSystemFont">UnlockRead</span>.</p>

<p class="NDLRefMemberFunction">void UnlockRead()</p>

<p class="NDLRefMemberDescription">Release the lock from reading.
Note that each call to <span class=
"NDLSystemFont">UnlockRead</span> must be matched to a call of
<span class="NDLSystemFont">LockRead</span>.</p>

<p class="NDLRefMemberFunction">void LockWrite()</p>

<p class="NDLRefMemberDescription">Acquire the lock for write
access. If another thread has acquired the lock for write access,
this call will block until the lock is free. If other threads
have acquired the lock for read access, this call will block all
further calls to <span class="NDLSystemFont">LockRead</span> and
block until all other threads have released the lock via
<span class="NDLSystemFont">UnlockRead</span>. Calls to
<span class="NDLSystemFont">LockWrite</span> may be nested, but
they must be matched by an equal number of calls to <span class=
"NDLSystemFont">UnlockRead</span>.</p>

<p class="NDLRefMemberFunction">void UnlockWrite()</p>

<p class="NDLRefMemberDescription">Release the lock from writing.
Note that each call to <span class=
"NDLSystemFont">UnlockWrite</span> must be matched to a call of
<span class="NDLSystemFont">LockWrite</span>.</p>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>
