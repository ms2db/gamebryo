<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>NiQuaternion</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2"
type="text/javascript">
</script><script language="JavaScript1.2" type="text/javascript">
WriteNavLink(2);
</script>

<p class="NDLRefHeadClassTitle">NiQuaternion</p>

<p class="NDLRefParentage">: public <a href=
"../../Reference/NiSystem/NiMemObject.htm"><span>NiMemObject</span></a></p>

<p class="NDLRefHeaderFile">&lt;NiQuaternion.h&gt;</p>

<p class="NDLRefHead1">Description</p>

<p>This class supports quaternions for representation of
rotations. Basic algebraic and calculus operations are provided.
The interpolation routines are used in the Gamebryo animation
module for keyframe animation.</p>

<p class="NDLRefHead1">Constructors</p>

<p class="NDLRefMemberFunction">NiQuaternion()</p>

<p class="NDLRefMemberDescription">The constructor does not
initialize the data members so that fast construction of arrays
is possible in situations where the quaternions will be filled in
by application code.</p>

<p class="NDLRefMemberFunction">NiQuaternion(float w, float x,
float y, float z)</p>

<p class="NDLRefMemberDescription">Creates the unit quaternion
that corresponds to the given components. It is the application's
responsibility to make sure that <span class=
"NDLSystemFont">[w,x,y,z]</span> is a unit-length vector.</p>

<p class="NDLRefMemberFunction">NiQuaternion(float fAngle, const
NiPoint3&amp; kAxis)</p>

<p class="NDLRefMemberDescription">Creates the unit quaternion
that corresponds to the rotation <span class=
"NDLSystemFont">fAngle</span> (in radians) about the specified
axis. This rotation is counter clockwise about the axis when
looking towards the origin.</p>

<p class="NDLRefHead1">Operators</p>

<p class="NDLRefMemberFunction">NiQuaternion operator+ (const
NiQuaternion&amp; kQ) const</p>

<p class="NDLRefMemberDescription">This operator is a
component-by-component addition operator.</p>

<p class="NDLRefMemberFunction">NiQuaternion operator- (const
NiQuaternion&amp; kQ) const</p>

<p class="NDLRefMemberDescription">This operator is a
component-by-component subtraction operator.</p>

<p class="NDLRefMemberFunction">NiQuaternion operator- ()
const</p>

<p class="NDLRefMemberDescription">This operator is a unary
negation operator.</p>

<p class="NDLRefMemberFunction">NiQuaternion operator* (const
NiQuaternion&amp; kQ) const</p>

<p class="NDLRefMemberDescription">This operator is a quaternion
multiplication operator.</p>

<p class="NDLRefMemberFunction">NiQuaternion operator* (float c)
const</p>

<p class="NDLRefMemberDescription">This operator is a scalar
multiplication operator.</p>

<p class="NDLRefMemberFunction">friend NiQuaternion operator*
(float c, const NiQuaternion&amp; kQ)</p>

<p class="NDLRefMemberDescription">This operator is a scalar
multiplication operator.</p>

<p class="NDLRefMemberFunction">bool operator== (const
NiQuaternion&amp; kQ) const</p>

<p class="NDLRefMemberDescription">This operator is an exact
equality operator.</p>

<p class="NDLRefMemberFunction">bool operator!= (const
NiQuaternion&amp; kQ) const</p>

<p class="NDLRefMemberDescription">This operator is an exact
inequality operator.</p>

<p class="NDLRefHead1">Static Member Functions</p>

<p class="NDLRefMemberFunction">static float Dot(const
NiQuaternion&amp; kP, const NiQuaternion&amp; kQ)</p>

<p class="NDLRefMemberDescription">Computes the dot product of
the two input quaternions by treating them as 4-tuples.</p>

<p class="NDLRefMemberFunction">static NiQuaternion
UnitInverse(const NiQuaternion&amp; kQ)</p>

<p class="NDLRefMemberDescription">The input quaternion must be
unit length. The returned value is the multiplicative inverse of
<span class="NDLSystemFont">kQ</span>.</p>

<p class="NDLRefMemberFunction">static NiQuaternion Exp(const
NiQuaternion&amp; kQ)</p>

<p class="NDLRefMemberFunction">static NiQuaternion Log(const
NiQuaternion&amp; kQ)</p>

<p class="NDLRefMemberDescription">These functions are the
exponential and logarithmic functions of the input unit length
quaternion, <span class="NDLSystemFont">kQ</span>. These
functions are used by the quaternion interpolation system (slerp
and squad).</p>

<p class="NDLRefMemberFunction">static NiQuaternion Slerp(float
t, const NiQuaternion&amp; kP, const NiQuaternion&amp; kQ)</p>

<p class="NDLRefMemberFunction">static void Slerp(float t, const
NiQuaternion&amp; kP, const NiQuaternion&amp; kQ, NiQuaternion*
pkResult)</p>

<p class="NDLRefMemberDescription">These functions compute the
spherical linear interpolant of the two input unit length
quaternions <span class="NDLSystemFont">kP</span> and
<span class="NDLSystemFont">kQ</span>. The input <span class=
"NDLSystemFont">t</span> is required to be in the interval
<span class="NDLSystemFont">[0,1]</span>. The functions assume
that the dot product of <span class="NDLSystemFont">kP</span> and
<span class="NDLSystemFont">kQ</span> is nonnegative (the angle
between <span class="NDLSystemFont">kP</span> and <span class=
"NDLSystemFont">kQ</span> is acute).</p>

<p class="NDLRefMemberFunction">static NiQuaternion
Intermediate(const NiQuaternion&amp; kQ0,
const NiQuaternion&amp; kQ1, const NiQuaternion&amp; kQ2)</p>

<p class="NDLRefMemberDescription">This function is used to
compute intermediate quaternions for use by <span class=
"NDLSystemFont">NiQuaternion::Squad</span> and <span class=
"NDLSystemFont">NiQuaternion::SquadExtraSpins</span>.</p>

<p class="NDLRefMemberFunction">static NiQuaternion Squad(float
t, const NiQuaternion&amp; kP, const NiQuaternion&amp; kA, const
NiQuaternion&amp; kB, const NiQuaternion&amp; kQ)</p>

<p class="NDLRefMemberDescription">This function computes the
spherical quadratic interpolant of the two input unit length
quaternions <span class="NDLSystemFont">kP</span> and
<span class="NDLSystemFont">kQ</span> where quaternions
<span class="NDLSystemFont">kA</span> and <span class=
"NDLSystemFont">kB</span> are computed by <span class=
"NDLSystemFont">NiQuaternion::Intermediate</span>. The input
<span class="NDLSystemFont">t</span> is required to be in the
interval <span class="NDLSystemFont">[0,1]</span>. The function
assumes that the dot product of <span class=
"NDLSystemFont">kP</span> and <span class=
"NDLSystemFont">kQ</span> is nonnegative (the angle between
<span class="NDLSystemFont">kP</span> and <span class=
"NDLSystemFont">kQ</span> is acute).</p>

<p class="NDLRefHead1">Supported Member Functions</p>

<p class="NDLRefMemberFunction">void SetW(float w)</p>

<p class="NDLRefMemberFunction">void SetX(float x)</p>

<p class="NDLRefMemberFunction">void SetY(float y)</p>

<p class="NDLRefMemberFunction">void SetZ(float z)</p>

<p class="NDLRefMemberFunction">float GetW() const</p>

<p class="NDLRefMemberFunction">float GetX() const</p>

<p class="NDLRefMemberFunction">float GetY() const</p>

<p class="NDLRefMemberFunction">float GetZ() const</p>

<p class="NDLRefMemberFunction">void SetValues(float w, float x,
float y, float z)</p>

<p class="NDLRefMemberFunction">void GetValues(float&amp; w,
float&amp; x, float&amp; y, float&amp; z) const</p>

<p class="NDLRefMemberDescription">Set and get accessors for the
quaternion components.</p>

<p class="NDLRefMemberFunction">void ToAngleAxis(float&amp;
fAngle, NiPoint3&amp; kAxis) const</p>

<p class="NDLRefMemberFunction">void FromAngleAxis(float fAngle,
const NiPoint3&amp; kAxis)</p>

<p class="NDLRefMemberDescription">These functions provide
conversions between quaternions and angle-axis representation.
The axes are unit length. <span class=
"NDLSystemFont">NiQuaternion::ToAngleAxis</span> makes two
function calls, one to <span class="NDLSystemFont">sqrt</span>
and one to <span class="NDLSystemFont">acos</span>. <span class=
"NDLSystemFont">NiQuaternion::FromAngleAxis</span> makes two
function calls, one to <span class="NDLSystemFont">sin</span> and
one to <span class="NDLSystemFont">cos</span>.</p>

<p class="NDLRefMemberFunction">void FromAngleAxisX(float
fAngle)</p>

<p class="NDLRefMemberFunction">void FromAngleAxisY(float
fAngle)</p>

<p class="NDLRefMemberFunction">void FromAngleAxisZ(float
fAngle)</p>

<p class="NDLRefMemberFunction">void FromAngleAxesXYZ(float
fAngleX, float fAngleY, float fAngleZ)</p>

<p class="NDLRefMemberDescription">Fast-path angle/axis functions
for basis vectors.</p>

<p class="NDLRefMemberFunction">void ToRotation(NiMatrix3&amp;
kRot) const</p>

<p class="NDLRefMemberFunction">void FromRotation(const
NiMatrix3&amp; kRot)</p>

<p class="NDLRefMemberDescription">These functions provide
conversions between quaternions and rotation matrices.
<span class="NDLSystemFont">NiQuaternion::ToRotation</span> uses
only arithmetic operations and is very fast. <span class=
"NDLSystemFont">NiQuaternion::FromRotation</span> makes one
function call to <span class="NDLSystemFont">sqrt</span>.</p>

<p class="NDLRefHead1">Notes</p>

<p>See <a href=
"../../Programmer/General_Topics/Transformations_and_Coordinate_Systems.htm">
Transformations and Coordinate Systems</a> for additional
reference.</p>

<a name="Convenience_Objects" id="Convenience_Objects"></a><p class="NDLRefHead2">Convenience Objects</p>

<p>The following public static constants are defined for
application convenience.</p>

  <table class="NDLNoteContainer" width="100%">
      <tr align="left">
          <td class="NDLNoteContainerTD"><p class="NDLHeadingNoteContainer">Caution</p>
              <div class="NDLNote">Since these constants are static, and not
<span class="NDLSystemFont">#defines</span>, applications must be
careful not to reference them in static data declarations, as
they may not be defined prior to the start of the "main"
function.)
              </div>
          </td>
      </tr>
  </table>

<!--(Table)=========================================================-->
<table>
    <thead>
        <tr>
            <th>Static Object</th>

            <th>Value</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class=
            "NDLSystemFont">NiQuaternion::IDENTITY</span></td>

            <td><span class="NDLSystemFont">NiQuaternion(1, 0, 0,
            0)</span></td>
        </tr>
    </tbody>
</table>

<p class="NDLRefHead2">Optimized Quaternion Interpolation</p>

<p>Gamebryo uses an optimized technique to interpolate
quaternions that is based on the article by Jonathon Blow in the
March 2002 issue of Game Developer Magazine. This algorithm is
implemented by the following code from
NiQuaternion_Win32.cpp:</p>

<pre>
//---------------------------------------------------------------------------
// Compute 1/sqrt(s) using a tangent line approximation.
// These constants are outside of the function because
// not all compilers are smart enough to precompute the values.
static const float ISQRT_NEIGHBORHOOD = 0.959066f;
static const float ISQRT_SCALE = 1.000311f;
static const float ISQRT_ADDITIVE_CONSTANT = ISQRT_SCALE /
    (float)sqrt(ISQRT_NEIGHBORHOOD);
static const float ISQRT_FACTOR = ISQRT_SCALE * (-0.5f /
    (ISQRT_NEIGHBORHOOD * (float)sqrt(ISQRT_NEIGHBORHOOD)));
inline float NiQuaternion::ISqrt_approx_in_neighborhood(float s)
{
    return ISQRT_ADDITIVE_CONSTANT + (s - ISQRT_NEIGHBORHOOD) * ISQRT_FACTOR;
}
//---------------------------------------------------------------------------
// Normalize a quaternion using the above approximation.
inline void NiQuaternion::FastNormalize()
{
    float s = m_fX*m_fX + m_fY*m_fY + m_fZ*m_fZ + m_fW*m_fW; // length^2
    float k = ISqrt_approx_in_neighborhood(s);
    if (s &lt;= 0.91521198f) {
        k *= ISqrt_approx_in_neighborhood(k * k * s);
        if (s &lt;= 0.65211970f) {
            k *= ISqrt_approx_in_neighborhood(k * k * s);
        }
    }
    m_fX *= k;
    m_fY *= k;
    m_fZ *= k;
    m_fW *= k;
}
//---------------------------------------------------------------------------
inline float NiQuaternion::Lerp(float v0, float v1, float fPerc)
{
    return v0 + fPerc * (v1 - v0);
}
//---------------------------------------------------------------------------
// CounterWarp: A helper function used by Slerp.
inline float NiQuaternion::CounterWarp(float t, float fCos)
{
    const float ATTENUATION = 0.82279687f;
    const float WORST_CASE_SLOPE = 0.58549219f;
    float fFactor = 1.0f - ATTENUATION * fCos;
    fFactor *= fFactor;
    float fK = WORST_CASE_SLOPE * fFactor;
    return t*(fK*t*(2.0f*t - 3.0f) + 1.0f + fK);
}
//---------------------------------------------------------------------------
NiQuaternion NiQuaternion::Slerp(float t, const NiQuaternion&amp; p,
    const NiQuaternion&amp; q)
{
    // assert:  Dot(p,q) &gt;= 0 (guaranteed in NiRotKey::Interpolate methods)
    // (but not necessarily true when coming from a Squad call)
    // This algorithm is Copyright (c) 2002 Jonathan Blow, from his article
    // "Hacking Quaternions" in Game Developer Magazine, March 2002.
    
    float fCos = Dot(p, q);
    float fTPrime;
    if (t &lt;= 0.5f) {
        fTPrime = CounterWarp(t, fCos);
    } else {
        fTPrime = 1.0f - CounterWarp(1.0f - t, fCos);
    }
    NiQuaternion kResult(
        Lerp(p.GetW(), q.GetW(), fTPrime),
        Lerp(p.GetX(), q.GetX(), fTPrime),
        Lerp(p.GetY(), q.GetY(), fTPrime),
        Lerp(p.GetZ(), q.GetZ(), fTPrime));
    kResult.FastNormalize();
    return kResult;
}
//---------------------------------------------------------------------------
</pre>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>
