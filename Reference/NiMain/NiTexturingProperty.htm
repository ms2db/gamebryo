<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>NiTexturingProperty</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2"
type="text/javascript">
</script><script language="JavaScript1.2" type="text/javascript">
WriteNavLink(2);
</script>

<p class="NDLRefHeadClassTitle">NiTexturingProperty</p>

<p class="NDLRefParentage">: public <u><span><a href=
"NiProperty.htm"><span>NiProperty</span></a></span></u></p>

<p class="NDLRefHeaderFile">&lt;NiTexturingProperty.h&gt;</p>

<p class="NDLRefHead1">Description</p>

<p>An <span class="NDLSystemFont">NiTexturingProperty</span>
allows the application control over the methods used to filter
the texture pixels and to blend the texture colors and vertex
colors. For more information regarding texturing and the types of
maps available, please refer to the <a href=
"../../Programmer/Texturing/Static_Multitexture_Usage_Basics.htm">
Texturing</a> document.</p>

<p class="NDLRefHead1">Constructors</p>

<p class="NDLRefMemberFunction">NiTexturingProperty()</p>

<p class="NDLRefMemberDescription">This default constructor
creates a property with no <span class=
"NDLSystemFont">Map</span>s and a blending apply mode of
<span class=
"NDLSystemFont">NiTexturingProperty::APPLY_MODULATE</span>.</p>

<p class="NDLRefMemberFunction">
NiTexturingProperty(const char* pcTextureName)</p>

<p class="NDLRefMemberDescription">Creates a property and creates
a base map using an <span class="NDLSystemFont">NiTexture</span>
created from the given image filename. The blending apply mode is
set to <span class=
"NDLSystemFont">NiTexturingProperty::APPLY_MODULATE</span>. 
Essentially, this function is a convenience function, that will
create a <span class="NDLSystemFont">NiTexturingProperty</span>
that is ready to be attached as-is to texture an object with the
image from the given image filename. If the image cannot be
created for any reason, then the behavior is the same as the
<span class="NDLSystemFont">NiTexturingProperty</span>'s default
constructor.</p>

<p class="NDLRefMemberFunction">NiTexturingProperty(<a href=
"NiPixelData.htm">NiPixelData</a>* pkPixelData)</p>

<p class="NDLRefMemberDescription">Creates a property and creates
a base map using an <span class="NDLSystemFont">NiTexture</span>
created from the given pixel data. The blending apply mode is
set to <span class=
"NDLSystemFont">NiTexturingProperty::APPLY_MODULATE</span>. 
Essentially, this function is a convenience function, that will
create a <span class="NDLSystemFont">NiTexturingProperty</span>
that is ready to be attached as-is to texture an object with the
image from the given pixel data. If the image cannot be created
for any reason, then the behavior is the same as the <span class=
"NDLSystemFont">NiTexturingProperty</span>'s default
constructor.</p>

<p class="NDLRefHead1">Static Member Functions</p>

<p class="NDLRefMemberFunction">static int GetType()</p>

<p class="NDLRefMemberFunction">static NiTexturingProperty*
GetDefault()</p>

<p class="NDLRefMemberDescription">See <span class=
"NDLSystemFont"><a href="NiProperty.htm">NiProperty</a></span>
for details on these non-virtual functions.</p><a name=
"Supported_Member_Functions" id="Supported_Member_Functions"></a>

<p class="NDLRefHead1">Supported Member Functions</p>

<p class="NDLRefHead2">Access Functions</p>

<p class="NDLRefMemberFunction">const <a href=
"NiTexturingProperty_Map.htm">Map</a>* GetBaseMap() const</p>

<p class="NDLRefMemberFunction"><a href=
"NiTexturingProperty_Map.htm">Map</a>* GetBaseMap()</p>

<p class="NDLRefMemberDescription">Retrieve the associated base
map, if it exists, or <span class="NDLSystemFont">NULL</span>
otherwise. The const version does not allow the <span class=
"NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> to be modified.</p>

<p class="NDLRefMemberFunction">void SetBaseMap(<a href=
"NiTexturingProperty_Map.htm">Map</a>* pkMap)</p>

<p class="NDLRefMemberDescription">Attaches the given map to the
<span class="NDLSystemFont">NiTexturingProperty</span> as a base
map. Note that there can be only one base map associated with a
given property, so if one is already attached, this function will
delete the old <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span>. Note also that the
<span class="NDLSystemFont">NiTexturingProperty</span> becomes
the owner of the <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> once it is attached,
and is responsible for deleting it.</p>

<p class="NDLRefMemberFunction">const <a href=
"NiTexturingProperty_BumpMap.htm">BumpMap</a>* GetBumpMap()
const</p>

<p class="NDLRefMemberFunction"><a href=
"NiTexturingProperty_BumpMap.htm">BumpMap</a>* GetBumpMap()</p>

<p class="NDLRefMemberDescription">Retrieve the associated bump
map, if it exists, or <span class="NDLSystemFont">NULL</span>
otherwise. The const version does not allow the <a href=
"NiTexturingProperty_BumpMap.htm"><span class=
"NDLSystemFont">BumpMap</span></a> to be modified. Note that
these functions return <span class="NDLSystemFont"><a href=
"NiTexturingProperty_BumpMap.htm">BumpMap</a></span> objects,
rather than <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> objects.</p>

<p class="NDLRefMemberFunction">void SetBumpMap(<a href=
"NiTexturingProperty_BumpMap.htm">BumpMap</a>* pkMap)</p>

<p class="NDLRefMemberDescription">Attaches the given bump map to
the <span class="NDLSystemFont">NiTexturingProperty</span> as a
bump map. Note that there can be only one bump map associated
with a given property, so if one is already attached, this
function will delete the old <span class="NDLSystemFont"><a href=
"NiTexturingProperty_BumpMap.htm">BumpMap</a></span>. Note also
that the <span class="NDLSystemFont">NiTexturingProperty</span>
becomes the owner of the <span class="NDLSystemFont"><a href=
"NiTexturingProperty_BumpMap.htm">BumpMap</a></span> once it is
attached, and is responsible for deleting it. Note that this
function takes a <span class="NDLSystemFont"><a href=
"NiTexturingProperty_BumpMap.htm">BumpMap</a></span> object,
rather than a <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> object.</p>

<p class="NDLRefMemberFunction">const <a href=
"NiTexturingProperty_Map.htm">Map</a>* GetDarkMap() const</p>

<p class="NDLRefMemberFunction"><a href=
"NiTexturingProperty_Map.htm">Map</a>* GetDarkMap()</p>

<p class="NDLRefMemberDescription">Retrieve the associated dark
map, if it exists, or <span class="NDLSystemFont">NULL</span>
otherwise. The const version does not allow the <span class=
"NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> to be modified.</p>

<p class="NDLRefMemberFunction">void SetDarkMap(<a href=
"NiTexturingProperty_Map.htm">Map</a>* pkMap)</p>

<p class="NDLRefMemberDescription">Attaches the given map to the
<span class="NDLSystemFont">NiTexturingProperty</span> as a dark
map. Note that there can be only one dark map associated with a
given property, so if one is already attached, this function will
delete the old <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span>. Note also that the
<span class="NDLSystemFont">NiTexturingProperty</span> becomes
the owner of the <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> once it is attached,
and is responsible for deleting it.</p>

<p class="NDLRefMemberFunction">const <a href=
"NiTexturingProperty_Map.htm">Map</a>* GetDetailMap() const</p>

<p class="NDLRefMemberFunction"><a href=
"NiTexturingProperty_Map.htm">Map</a>* GetDetailMap()</p>

<p class="NDLRefMemberDescription">Retrieve the associated detail
map, if it exists, or <span class="NDLSystemFont">NULL</span>
otherwise. The const version does not allow the <span class=
"NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> to be modified.</p>

<p class="NDLRefMemberFunction">void SetDetailMap(<a href=
"NiTexturingProperty_Map.htm">Map</a>* pkMap)</p>

<p class="NDLRefMemberDescription">Attaches the given map to the
<span class="NDLSystemFont">NiTexturingProperty</span> as a
detail map. Note that there can be only one detail map associated
with a given property, so if one is already attached, this
function will delete the old <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span>. Note also that the
<span class="NDLSystemFont">NiTexturingProperty</span> becomes
the owner of the <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> once it is attached,
and is responsible for deleting it.</p>

<p class="NDLRefMemberFunction">const <a href=
"NiTexturingProperty_Map.htm">Map</a>* GetGlossMap() const</p>

<p class="NDLRefMemberFunction"><a href=
"NiTexturingProperty_Map.htm">Map</a>* GetGlossMap()</p>

<p class="NDLRefMemberDescription">Retrieve the associated gloss
map, if it exists, or <span class="NDLSystemFont">NULL</span>
otherwise. The const version does not allow the <span class=
"NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> to be modified.</p>

<p class="NDLRefMemberFunction">void SetGlossMap(<a href=
"NiTexturingProperty_Map.htm">Map</a>* pkMap)</p>

<p class="NDLRefMemberDescription">Attaches the given map to the
<span class="NDLSystemFont">NiTexturingProperty</span> as a gloss
map. Note that there can be only one gloss map associated with a
given property, so if one is already attached, this function will
delete the old <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span>. Note also that the
<span class="NDLSystemFont">NiTexturingProperty</span> becomes
the owner of the <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> once it is attached,
and is responsible for deleting it.</p>

<p class="NDLRefMemberFunction">const <a href=
"NiTexturingProperty_Map.htm">Map</a>* GetGlowMap() const</p>

<p class="NDLRefMemberFunction"><a href=
"NiTexturingProperty_Map.htm">Map</a>* GetGlowMap()</p>

<p class="NDLRefMemberDescription">Retrieve the associated glow
map, if it exists, or <span class="NDLSystemFont">NULL</span>
otherwise. The const version does not allow the <span class=
"NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> to be modified.</p>

<p class="NDLRefMemberFunction">void SetGlowMap(<a href=
"NiTexturingProperty_Map.htm">Map</a>* pkMap)</p>

<p class="NDLRefMemberDescription">Attaches the given map to the
<span class="NDLSystemFont">NiTexturingProperty</span> as a glow
map. Note that there can be only one glow map associated with a
given property, so if one is already attached, this function will
delete the old <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span>. Note also that the
<span class="NDLSystemFont">NiTexturingProperty</span> becomes
the owner of the <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> once it is attached,
and is responsible for deleting it.</p>

<p class="NDLRefMemberFunction">const <a href=
"NiTexturingProperty_Map.htm">Map</a>* GetNormalMap() const</p>

<p class="NDLRefMemberFunction"><a href=
"NiTexturingProperty_Map.htm">Map</a>* GetNormalMap()</p>

<p class="NDLRefMemberDescription">Retrieve the associated normal
map, if it exists, or <span class="NDLSystemFont">NULL</span>
otherwise. The const version does not allow the <span class=
"NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> to be modified.</p>

<p class="NDLRefMemberFunction">void SetNormalMap(<a href=
"NiTexturingProperty_Map.htm">Map</a>* pkMap)</p>

<p class="NDLRefMemberDescription">Attaches the given map to the
<span class="NDLSystemFont">NiTexturingProperty</span> as a
normal map. Note that there can be only one normal map associated
with a given property, so if one is already attached, this
function will delete the old <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span>. Note also that the
<span class="NDLSystemFont">NiTexturingProperty</span> becomes
the owner of the <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> once it is attached,
and is responsible for deleting it.</p>

<p class="NDLRefMemberFunction">const <a href=
"NiTexturingProperty__ParallaxMap.htm">ParallaxMap</a>*
GetParallaxMap() const</p>

<p class="NDLRefMemberFunction"><a href=
"NiTexturingProperty__ParallaxMap.htm">ParallaxMap</a>*
GetParallaxMap()</p>

<p class="NDLRefMemberDescription">Retrieve the associated
parallax map, if it exists, or <span class=
"NDLSystemFont">NULL</span> otherwise. The const version does not
allow the <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> to be modified.</p>

<p class="NDLRefMemberFunction">void SetParallaxMap(<a href=
"NiTexturingProperty__ParallaxMap.htm">ParallaxMap</a>* pkMap)</p>

<p class="NDLRefMemberDescription">Attaches the given map to the
<span class="NDLSystemFont">NiTexturingProperty</span> as a
parallax map. Note that there can be only one parallax map
associated with a given property, so if one is already attached,
this function will delete the old <span class=
"NDLSystemFont"><a href=
"NiTexturingProperty__ParallaxMap.htm">ParallaxMap</a></span>.
Note also that the <span class=
"NDLSystemFont">NiTexturingProperty</span> becomes the owner of
the <a href="NiTexturingProperty__ParallaxMap.htm"><span class=
"NDLSystemFont">ParallaxMap</span></a> once it is attached, and
is responsible for deleting it.</p>

<p class="NDLRefMemberFunction">const <a href=
"NiTexturingProperty_Map.htm">Map</a>*
GetDecalMap(unsigned int uiIndex) const</p>

<p class="NDLRefMemberFunction"><a href=
"NiTexturingProperty_Map.htm">Map</a>*
GetDecalMap(unsigned int uiIndex)</p>

<p class="NDLRefMemberDescription">Retrieve the decal map at the
given index, if it exists, or <span class=
"NDLSystemFont">NULL</span> otherwise. The const version does not
allow the <a href="NiTexturingProperty_Map.htm"><span class=
"NDLSystemFont">Map</span></a> to be modified.</p>

<p class="NDLRefMemberFunction">void
SetDecalMap(unsigned int uiIndex, <a href=
"NiTexturingProperty_Map.htm">Map</a>* pkMap)</p>

<p class="NDLRefMemberDescription">Attaches the given map to the
<span class="NDLSystemFont">NiTexturingProperty</span> at the
given index as a decal map. Note that there can be only one decal
map associated with a given property at each index, so if one is
already attached at the index, this function will delete the old
<span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span>. Note also that the
<span class="NDLSystemFont">NiTexturingProperty</span> becomes
the owner of the <span class="NDLSystemFont"><a href=
"NiTexturingProperty_Map.htm">Map</a></span> once it is attached,
and is responsible for deleting it. If the index is greater than
the number of array slots allocated for decal maps, the array
will be resized to fit the new map.</p>

<p class="NDLRefMemberFunction">unsigned int GetDecalArrayCount()
const</p>

<p class="NDLRefMemberDescription">Returns the total number of
array slots allocated for decal maps. This quantity will be
greater than or equal to the number of decal maps (due to the
possibility of holes in the array).</p>

<p class="NDLRefMemberFunction">unsigned int GetDecalMapCount()
const</p>

<p class="NDLRefMemberDescription">Returns the total number of
decal maps that have been attached to the property.</p>

<p class="NDLRefMemberFunction">const <a href=
"NiTexturingProperty_ShaderMap.htm">ShaderMap</a>*
GetShaderMap(unsigned int uiIndex) const</p>

<p class="NDLRefMemberFunction"><a href=
"NiTexturingProperty_ShaderMap.htm">ShaderMap</a>*
GetShaderMap(unsigned int uiIndex)</p>

<p class="NDLRefMemberDescription">Retrieve the <a href=
"NiTexturingProperty_ShaderMap.htm"><span class=
"NDLSystemFont">ShaderMap</span></a> at the given index, if it
exists, or <span class="NDLSystemFont">NULL</span> otherwise. 
The const version does not allow the <span class=
"NDLSystemFont"><a href=
"NiTexturingProperty_ShaderMap.htm">ShaderMap</a></span> to be
modified.</p>

<p class="NDLRefMemberFunction">void SetShaderMap(unsigned int
uiIndex, <a href=
"NiTexturingProperty_ShaderMap.htm">ShaderMap</a>* pkMap)</p>

<p class="NDLRefMemberDescription">Attaches the given
<span class="NDLSystemFont"><a href=
"NiTexturingProperty_ShaderMap.htm">ShaderMap</a></span> at the
given index. Note also that the <span class=
"NDLSystemFont">NiTexturingProperty</span> becomes the owner of
the <span class="NDLSystemFont">Map</span> once it is attached,
and is responsible for deleting it. If the index is greater than
the number of array slots allocated for decal maps, the array
will be resized to fit the new map.</p>

<p class="NDLRefMemberFunction">unsigned int
GetShaderArrayCount() const</p>

<p class="NDLRefMemberDescription">Returns the total number of
array slots allocated for shader maps. This quantity will be
greater than or equal to the number of shader maps (due to the
possibility of holes in the array).</p>

<p class="NDLRefMemberFunction">unsigned int GetShaderMapCount()
const</p>

<p class="NDLRefMemberDescription">Returns the total number of
shader maps that have been attached to the property.</p>

<p class="NDLRefMemberFunction">const NiMapArray&amp; GetMaps()
const</p>

<p class="NDLRefMemberDescription">Returns the array of maps,
where each map type is stored at the position indicated in the
<a href="NiTexturingProperty.htm#Map_Indices">MapEnum</a>
enumerations.</p>

<p class="NDLRefMemberFunction">void SetMap(unsigned int uiIndex,
Map* pkMap)</p>

<p class="NDLRefMemberDescription">Sets the map corresponding to
the <a href="NiTexturingProperty.htm#Map_Indices">MapEnum</a>
enumeration index. Note that shader maps cannot be set with this member
function.</p>

<p class="NDLRefHead2">Apply Modes</p>

<p class="NDLRefMemberFunction">ApplyMode GetApplyMode()
const</p>

<p class="NDLRefMemberFunction">void SetApplyMode(<a href=
"NiTexturingProperty.htm#Texture_Apply_Modes">ApplyMode</a>
eApplymode)</p>

<p class="NDLRefMemberDescription">Retrieve and set the texture
apply mode. The texture apply mode determines how the vertex
colors (whose generation are controlled via the <span class=
"NDLSystemFont">NiVertexColorProperty</span>) are blended with
the filtered texture color. Supported apply modes are described
in the Gamebryo Texturing Manual.</p>

<p class="NDLRefHead2">Other Functions</p>

<p class="NDLRefMemberFunction">bool
IsEqualFast(const NiTexturingProperty&amp; kProp) const</p>

<p class="NDLRefMemberDescription">See <span class=
"NDLSystemFont">NiProperty</span> for details on this non-virtual
function.</p>

<p class="NDLRefMemberFunction">virtual int Type() const</p>

<p class="NDLRefMemberDescription">See <span class=
"NDLSystemFont">NiProperty</span> for details on this
function.</p>

<p class="NDLRefMemberFunction">bool IsMultiTexture() const</p>

<p class="NDLRefMemberDescription">Returns a Boolean indicating
whether any multitexture maps (dark, detail, gloss, glow, bump,
or decal maps) are attached to the <span class=
"NDLSystemFont">NiTexturingProperty</span>.</p><a name=
"Base_Map_Access" id="Base_Map_Access"></a>

<p class="NDLRefHead2">Base Map Access</p>

<p class="NDLRefMemberFunction"><a href=
"NiTexture.htm">NiTexture</a>* GetBaseTexture() const</p>

<p class="NDLRefMemberFunction">void SetBaseTexture(<a href=
"NiTexture.htm">NiTexture</a>* pkTexture)</p>

<p class="NDLRefMemberDescription">Sets and retrieves the
<span class="NDLSystemFont"><a href=
"NiTexture.htm">NiTexture</a></span> associated with the base
map.</p>

<p class="NDLRefMemberFunction"><a href=
"#Texture_Clamping_Modes">ClampMode</a> GetBaseClampMode()
const</p>

<p class="NDLRefMemberFunction">void SetBaseClampMode(<a href=
"#Texture_Clamping_Modes">ClampMode</a> eMode)</p>

<p class="NDLRefMemberDescription">Retrieve and set the texture
coordinate clamping (or addressing) mode for the base map. The
texture-clamping mode determines how texture coordinates outside
of the range <span class="NDLSystemFont">[0.0,1.0]</span> are
handled by the texturing system. Supported clamping modes are
described in the <a href=
"../../Programmer/Texturing/Texture_Coordinate_Wrapping_and_Clamping.htm">
Gamebryo Texturing Manual</a>.</p>

<p class="NDLRefMemberFunction"><a href=
"NiTexturingProperty.htm#Texture_Filter_Modes">FilterMode</a>
GetBaseFilterMode() const</p>

<p class="NDLRefMemberFunction">void SetBaseFilterMode(<a href=
"NiTexturingProperty.htm#Texture_Filter_Modes">FilterMode</a> eMode)</p>

<p class="NDLRefMemberDescription">Retrieve and set the texture
filter mode for the base map. The texture filter mode controls
how the texture is indexed and filtered to produce a
representative color at a given pixel in a polygon. Supported
filter modes are described in the <a href=
"../../Programmer/Texturing/Texture_Pixel_Interpolation_and_Filtering.htm">
Gamebryo Texturing Manual</a>.</p>

<p class="NDLRefMemberFunction">unsigned int
GetBaseTextureIndex() const</p>

<p class="NDLRefMemberFunction">void
SetBaseTextureIndex(unsigned int uiIndex)</p>

<p class="NDLRefMemberDescription">Retrieves and sets the texture
coordinate-index for the base map.</p>

<p class="NDLRefMemberFunction">NiTextureTransform*
GetBaseTextureTransform() const</p>

<p class="NDLRefMemberFunction">void
SetBaseTextureTransform(NiTextureTransform* pkTransform)</p>

<p class="NDLRefMemberDescription">Retrieves and sets the texture
transform for the base map.</p>

<p class="NDLRefHead1">Notes</p>

<p class="NDLRefHead2">Texturing Details</p>

<p>For detailed documentation on the use of texturing and
multi-texturing, please see the Gamebryo texturing
documentation. </p>

<p>For details on ShaderMaps, see the <a href=
"../../Programmer/NiShader/Introduction_to_Gamebryo_s_Shader_System.htm">
NiShader</a> documentation.</p>

<a name="Texture_Clamping_Modes" id="Texture_Clamping_Modes"></a><p class="NDLRefHead2">Texture Clamping Modes</p>

<p>The table below lists the four texture clamping modes that are
supported by Gamebryo and their corresponding behaviors. Specific
renderers may or may not be able to support a specific
texture-clamping mode--see the Texturing document for details.
Note that all clamping modes are declared in the scope of
<span class="NDLSystemFont">NiTexturingProperty</span>, and the
names must be qualified as such.</p>

<!--(Table)=========================================================-->
<table>
    <thead>
        <tr>
            <th>Clamping Mode</th>

            <th>Behavior</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class=
            "NDLSystemFont">CLAMP_S_CLAMP_T</span></td>

            <td>Causes edge-replication to infinity in both
            dimensions.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">CLAMP_S_WRAP_T</span></td>

            <td>Causes edge-replication to infinity in the
            horizontal texture direction, and infinite tiling in
            the vertical texture direction.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">WRAP_S_CLAMP_T</span></td>

            <td>Causes edge-replication to infinity in the
            vertical texture direction, and infinite tiling in
            the horizontal texture direction.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">WRAP_S_WRAP_T</span></td>

            <td>Causes infinite tiling of texture in both
            dimensions.</td>
        </tr>
    </tbody>
</table>

<a name="Texture_Apply_Modes" id="Texture_Apply_Modes"></a><p class="NDLRefHead2">Texture Apply Modes</p>

<p>The table below lists the five texture-apply modes that are
supported by Gamebryo and their corresponding equations. 
Specific renderers may or may not be able to support a specific
apply mode -- see the Texturing document for details.</p>

<p>Note that all apply modes are declared in the scope of
<span class="NDLSystemFont">NiTexturingProperty</span>, and the
names must be qualified as such.</p>

<!--(Table)=========================================================-->
<table>
    <thead>
        <tr>
            <th>Apply Mode</th>

            <th>Color &amp; Alpha: Common Application</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class=
            "NDLSystemFont">APPLY_REPLACE</span></td>

            <td><b>C<sub>R</sub> = C<sub>T</sub>, A<sub>R</sub> =
            A<sub>T</sub></b>: Basic texturing without any
            dynamic or static vertex-based lighting.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">APPLY_DECAL</span></td>

            <td><b>C<sub>R</sub> = C<sub>T</sub> * A<sub>T</sub>
            + CV * (1-A<sub>T</sub>), A<sub>R</sub> =
            A<sub>V</sub></b>: Decal or bullet-hole textures on a
            base untextured surface.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">APPLY_MODULATE</span></td>

            <td><b>C<sub>R</sub> = C<sub>T</sub> * C<sub>V</sub>,
            A<sub>R</sub> = A<sub>T</sub> * A<sub>V</sub></b>:
            Texture and final vertex colors and alpha values are
            multiplied component-by-component. In predecessors
            of Gamebryo, this mode was known as <span class=
            "NDLSystemFont">APPLY_MULTALPHA</span>.</td>
        </tr>
    </tbody>
</table>

<a name="Texture_Filter_Modes" id="Texture_Filter_Modes"></a><p class="NDLRefHead2">Texture Filter Modes</p>

<p>Gamebryo supports the following texture filter modes, although
specific renderers may or may not be able to support all of them
in all texture modes. See the Texturing document for
details.</p>

<p>Note that all filter modes are declared in the scope of
<span class="NDLSystemFont">NiTexturingProperty</span>, and the
names must be qualified as such.</p>

<!--(Table)=========================================================-->
<table>
    <thead>
        <tr>
            <th>Filter Mode</th>

            <th>Description</th>
        </tr>
    </thead>

    <tbody>
        <tr>
            <td><span class=
            "NDLSystemFont">FILTER_NEAREST</span></td>

            <td>Uses nearest texel, with no mipmapping.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">FILTER_BILERP</span></td>

            <td>Uses linear interpolation with no
            mipmapping.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">FILTER_TRILERP</span></td>

            <td>Linearly interpolates between the eight texels
            (the 4 closest texels on each of the two closest
            mipmap levels).</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">FILTER_NEAREST_MIPNEAREST</span></td>

            <td>Selects nearest mipmap level, then uses nearest
            texel on that level.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">FILTER_NEAREST_MIPLERP</span></td>

            <td>Selects nearest texel on each of the two nearest
            mipmap levels and linearly interpolates between
            them.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">FILTER_BILERP_MIPNEAREST</span></td>

            <td>Selects nearest mipmap level, then linearly
            interpolates on it.</td>
        </tr>

        <tr>
            <td><span class=
            "NDLSystemFont">FILTER_ANISOTROPIC</span></td>

            <td>Performs one or more trilinear samples depending
            on the orientation of anisotropy. The maximum number
            of samples or taps taken is set by the value from
            NiTexturingProperty::Map::GetMaxAnisotropy().</td>
        </tr>
    </tbody>
</table>

<a name="Map_Indices" id="Map_Indices"></a><p class="NDLRefHead2">Map Indices</p>

<p>MapEnum enumerates the positions of texture maps:</p>

<pre>
enum MapEnum
    {
        BASE_INDEX,
        DARK_INDEX,
        DETAIL_INDEX,
        GLOSS_INDEX,
        GLOW_INDEX,
        BUMP_INDEX,
        NORMAL_INDEX,
        PARALLAX_INDEX,
        DECAL_BASE,
        SHADER_BASE,
        INDEX_MAX
    };
</pre>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>
