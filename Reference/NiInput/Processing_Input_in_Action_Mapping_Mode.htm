<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>Processing Input in Action Mapping Mode</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script> <script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<h1>Processing Input in Action Mapping Mode</h1>

<p>All processing of data when operating in <em>Action 
 Mapping Mode</em> is accomplished via popping instances of actions (<span 
 class="NDLSystemFont"><a href="NiActionData.htm">NiActionData</a></span>) 
 off the input system action queue. <span class="NDLSystemFont">NiInputSystem</span> 
 contains a set of functions that facilitate these operations. These functions 
 are listed below:</p>

<ul>
<li><span class="NDLSystemFont"><a href="NiInputSystem.htm#NiInputSystem::GetActionDataCount">NiInputSystem::GetActionDataCount</a></span></li>
<li><a href="NiInputSystem.htm#NiInputSystem::PopActionData">NiInputSystem::PopActionData</a></li>
<li><a href="NiInputSystem.htm#NiInputSystem::ReleaseActionData">NiInputSystem::ReleaseActionData</a></li>
<li><a href="NiInputSystem.htm#NiInputSystem::GetFirstActionData">NiInputSystem::GetFirstActionData</a></li>
<li><a href="NiInputSystem.htm#NiInputSystem::GetNextActionData">NiInputSystem::GetNextActionData</a></li>
</ul>


<p>You may note that it is possible to process an action 
 mapped application without actually 'grabbing' any device instances from 
 the system. </p>

<p>Application should ideally only use PopActionData, as 
 it properly removes items from the queue. The <span class="NDLSystemFont">GetFirstActionData</span> 
 and <span class="NDLSystemFont">GetNextActionData</span> functions are supplied 
 to allow for reviewing actions without removing them from the queue.  Once
 the action has been handled, then <span class="NDLSystemFont">ReleaseActionData</span>
 should be called to return the action object to the pool.</p>

<p>Each instance of action data contains the following 
 information:</p>

<ul>
	
	<li>The application supplied 
 'app data' field.</li>
	
	<li>The physical data from 
 the device (mapped to the correct range for axes).</li>
	
	<li>A sequence number identifying 
 when it occurred.</li>
	
	<li>The ID of the device 
 that generated the action.</li>
	
	<li>The context data that 
 was assigned to the action when it was created.</li>
</ul>

<p>For complete information on the contents of the action 
 data instances returned by the system, please refer to the <span class="NDLSystemFont"><a 
 href="NiActionData.htm">NiActionData</a></span> 
 reference.</p>

<p>The following code block demonstrates how an application 
 would process an action mapped update:</p>

<pre>
// This code assumes m_spInputSystem holds a valid instance of the
// input system. It also assumes UpdateActionMap has been called
// prior to this code block!
//
// Pop each ActionData instance off the stack, and process it.
NiActionData* pkActionData = m_spInputSystem-&gt;PopActionData();
while (pkActionData)
{
    // Process the pkActionData returned by the system here!
    // i.e., ProcessActionData(pkActionData);
    m_spInputSystem-&gt;ReleaseActionData(pkActionData);
    pkActionData = m_spInputSystem-&gt;PopActionData();
}
</pre> 

<p>The action mapping system itself is flexible in that 
 it allow for customers to utilize a variety of methods to handle actions. 
 By using the <span class="NDLSystemFont">m_uiAppData</span> and <span class="NDLSystemFont">m_pvContext</span> 
 fields of the <span class="NDLSystemFont"><a href="NiAction.htm">NiAction</a></span> 
 class, several options exist for processing actions.</p>

<p>Below, we take the three examples from the <a href="Setting_up_an_Action_Map.htm">Setting 
 up an Action Map</a> section and demonstrate how they would be processed 
 in an application. </p>

<a name="Enumeration_Method"></a><h2>The Enumeration Method</h2>

<p>In this section, we will demonstrate how to process 
 the action data generated by the map setup in the <a href="Setting_up_an_Action_Map.htm">Setting 
 Up An Action Map</a> section of the documentation. 
 We will expand upon the processing loop demonstrated above:</p>

<pre>
// Pop each ActionData instance off the stack, and process it.
NiActionData* pkActionData = m_spInputSystem-&gt;PopActionData();
while (pkActionData)
{
    switch (pkActionData-&gt;GetAppData())
    {
    case eActionCode_0:
        // Handle ActionCode_0
        break;
    case eActionCode_1:
        // Handle ActionCode_1
        break;
    default:
        // An unknown action code...
        break;
    }
    m_spInputSystem-&gt;ReleaseActionData(pkActionData);
    pkActionData = m_spInputSystem-&gt;PopActionData();
}
</pre>

<p>As you can see, this approach is easily handled by having 
 a simple switch statement that handles each enumerated action appropriately. 
 The problem with this method is that the switch statement can become quite 
 large and therefore hard to manage/up-keep.</p>

<a name="Unique_Callback_Method"></a><h2>The Unique Callback Method</h2>

<p>In this section, we will demonstrate how to process 
 the action data that was generated by the map setup in the <a href="Setting_up_an_Action_Map.htm">Setting 
 Up An Action Map</a> section of the documentation.</p>

<p>We will again expand upon the processing loop demonstrated 
 above:</p>

<pre>
// We need a pointer to the callback function
EXECUTEACTIONCALLBACK pfnCallback;
 
// Pop each ActionData instance off the stack, and process it.
NiActionData* pkActionData = m_spInputSystem-&gt;PopActionData();
while (pkActionData)
{
    pfnCallback = (EXECUTEACTIONCALLBACK)(pkActionData-&gt;GetAppData());
    assert(pfnCallback);
    if (!pfnCallback(pkActionData))
    {
        // The callback failed. The application should handle this.
    }
    m_spInputSystem-&gt;ReleaseActionData(pkActionData);
    pkActionData = m_spInputSystem-&gt;PopActionData();
}
</pre> 

<p>As you can see, this approach is much cleaner but it 
 is not without its problems. For each action your application supports, 
 an action execution function will have to be coded. This can quickly lead 
 to several dozen extra functions to care for.</p>

<a name="Hybrid_Callback_Method"></a><h2>The Hybrid Callback Method</h2>

<p>In this section, we will demonstrate how to process 
 the action data that was generated by the map setup in the <a href="Setting_up_an_Action_Map.htm">Setting 
 Up An Action Map</a> section of the documentation.</p>

<p>The processing loop is identical to that in the Unique 
 method, save for the fact that we get the callback function pointer from 
 the context instead of the app data field of the action data:</p>
 
<pre>
// We need a pointer to the callback function
EXECUTEACTIONCALLBACK pfnCallback;
 
// Pop each ActionData instance off the stack, and process it.
NiActionData* pkActionData = m_spInputSystem-&gt;PopActionData();
while (pkActionData)
{
    pfnCallback = (EXECUTEACTIONCALLBACK)(pkActionData-&gt;GetAppData());
    assert(pfnCallback);
    if (!pfnCallback(pkActionData))
    {
        // The callback failed. The application should handle this.
    }
    m_spInputSystem-&gt;ReleaseActionData(pkActionData);
    pkActionData = m_spInputSystem-&gt;PopActionData();
}
</pre> 

<p>While this loop is identical to the Unique method, this 
 method provides an advantage by allowing for similar actions to be handled 
 in a single execute action function. The function itself can differentiate 
 between the enumerations contained in the app data field. The logical 
 grouping of actions into a single function can make writing input processing 
 code somewhat easier than the previous two methods.</p>

<p>Of course, you should use whatever approach best suits 
 your application.</p>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>
