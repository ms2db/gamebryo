<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>efd::SmartPointer</title>
<!--(Begin Meta)================================================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Expedition" />
<meta name="Generator" content="DoxyConvert by Emergent Game Technologies - http://emergent.net" />

<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)==================================================================================-->
    
<!--(Begin Links)===============================================================================-->

<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=================================================================================-->

</head>
  
<!--(Body)======================================================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<p class="NDLRefHeadClassTitle">efd::SmartPointer</p>
<p class="NDLRefParentage">: public <span class="NDLSystemFont"><a href="efd__MemObject.htm">efd::MemObject</a></span></p>


<p class="NDLRefHeaderFile">&lt;SmartPointer.h&gt;</p>

<p class="NDLRefHead1" style="text-align: center; ">
<div class="FigureContainer">
  <img src="./images/classefd_1_1_smart_pointer.gif" alt="Inheritance graph for efd::SmartPointer"/>
  <p class="FigureCaption">Inheritance graph for efd::SmartPointer</p>
</div>
</p>

<p class="NDLRefHead1">Description</p>
<p class="NDLNormal">Smart pointer for reference counting objects. </p>
<p class="NDLNormal">The class T must contain IncRefCount and DecRefCount methods. It does not have to be derived from any specific base class as long as it implements these methods. Suitable methods include using one of the following macros in a class definition: EE_DECLARE_ABSTRACT_REFCOUNT (+ implementations of the methods) EE_DECLARE_CONCRETE_REFCOUNT EE_DECLARE_CONCRETE_ATOMIC_REFCOUNT or deriving from the following class: <span class="NDLSystemFont"><a href="efd__RefCount.htm">efd::RefCount</a></span><span class="NDLSystemFont"><a href="../NiMain/NiRefObject.htm">NiRefObject</a></span> or using one of these templates to make a reference counted wrapper: efd::RefCounted&lt;&gt; efd::RefCountedMemObject&lt;&gt;</p>
<p class="NDLNormal">Assignment of a non-NULL pointer to this class will cause IncRefCount to be called on the pointer.</p>
<p class="NDLNormal">If the smart pointer contains a non-NULL pointer when a different pointer is assigned or when the <span class="NDLSystemFont">SmartPointer</span> is destructed, then it will call DecRefCount on the existing pointer.</p>
<p class="NDLNormal">DecRefCount will typically be implemented such that dropping to zero will delete the object. </p>

<a name="public_methods"></a>
<p class="NDLRefHead1">Public Methods</p>


<a name="classefd_1_1_smart_pointer_1a7eb15f16143db8a6cd282ffd57239ce7"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) )</p>
<p class="NDLRefMemberDescription">Constructor that takes a pointer to a reference counted object. </p>
<p class="NDLRefMemberDetailedDescription">It will add a reference (call IncRefCount) if pObject is non-NULL. </p>

<a name="classefd_1_1_smart_pointer_1ae651895ee62b1c3a2ac63aada46c5e60"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) ) const</p>
<p class="NDLRefMemberDescription">Constructor that takes another smart pointer. </p>
<p class="NDLRefMemberDetailedDescription">It will add a reference if the pointer object contains a non-NULL value. </p>

<a name="classefd_1_1_smart_pointer_1a8d3db20f1cd76c72b6ad0092236d6812"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) )</p>
<p class="NDLRefMemberDescription">Destructor; it will remove a reference (DecRefCount) if the contained pointer is non-NULL. </p>

<a name="classefd_1_1_smart_pointer_1a43236f056808da758b224d4b68f354c4"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) ) const</p>
<p class="NDLRefMemberDescription">Implicit conversion to the underlying pointer type. </p>

<a name="classefd_1_1_smart_pointer_1ac8e1614942c03b891890897a46018e87"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) ) const</p>
<p class="NDLRefMemberDescription">Explicit conversion to the underlying pointer type. </p>

<a name="classefd_1_1_smart_pointer_1abb4abc6b222ef4bd2f48b8860bb5e18b"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) )</p>
<p class="NDLRefMemberDescription">Swaps the underlying pointer values of two smart pointer objects. </p>
<p class="NDLRefMemberDetailedDescription">Using this method is significantly faster for atomic refcounted objects than writing code of the form: SmartPointer&lt;T&gt; x = a; a = b; b = x; </p>
<a name="pointer_assignment_operators."></a>
<p class="NDLRefHead1">Pointer assignment operators.</p>


<a name="classefd_1_1_smart_pointer_1aef810f88ccd28d20c532e7abc4352597"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) )</p>
<p class="NDLRefMemberFunction"></p>

<a name="classefd_1_1_smart_pointer_1aef810f88ccd28d20c532e7abc4352597"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) )</p>
<p class="NDLRefMemberFunction"></p>
<a name="pointer_comparison_operators."></a>
<p class="NDLRefHead1">Pointer comparison operators.</p>


<a name="classefd_1_1_smart_pointer_1aed8b87d6cb1a85270386adcf0928c155"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) )</p>
<p class="NDLRefMemberFunction"></p>

<a name="classefd_1_1_smart_pointer_1ad414e313cd20545261ace04a67d5bd8c"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) )</p>
<p class="NDLRefMemberFunction"></p>

<a name="classefd_1_1_smart_pointer_1aed8b87d6cb1a85270386adcf0928c155"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) )</p>
<p class="NDLRefMemberFunction"></p>

<a name="classefd_1_1_smart_pointer_1ad414e313cd20545261ace04a67d5bd8c"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) )</p>
<p class="NDLRefMemberFunction"></p>

<a name="classefd_1_1_smart_pointer_1a3d3b0e736910c249d9ed8ad2ace47ae3"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) ) const</p>
<p class="NDLRefMemberFunction"></p>

<a name="classefd_1_1_smart_pointer_1a5be339d4204741953a0123c01b621c35"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) ) const</p>
<p class="NDLRefMemberFunction"></p>

<a name="classefd_1_1_smart_pointer_1aa9bf493642ced19ce4c85dcc807cfc9e"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) ) const</p>
<p class="NDLRefMemberFunction"></p>

<a name="classefd_1_1_smart_pointer_1adaa83c482bc6316e76a22da96ad3c6a0"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) ) const</p>
<p class="NDLRefMemberFunction"></p>
<a name="'pointer-like'_operators."></a>
<p class="NDLRefHead1">'Pointer-like' operators.</p>


<a name="classefd_1_1_smart_pointer_1a888c6a9842ba5b33b7bc8781a3961d04"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) ) const</p>
<p class="NDLRefMemberFunction"></p>

<a name="classefd_1_1_smart_pointer_1aad7d38dcfd7acedff5d605c53e79db0a"></a>
<p class="NDLRefMemberFunction">__attribute__((__always_inline__) ) const</p>
<p class="NDLRefMemberFunction"></p>
 
<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>
