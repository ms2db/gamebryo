<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>efd::StreamMessage</title>
<!--(Begin Meta)================================================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Expedition" />
<meta name="Generator" content="DoxyConvert by Emergent Game Technologies - http://emergent.net" />

<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)==================================================================================-->
    
<!--(Begin Links)===============================================================================-->

<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=================================================================================-->

</head>
  
<!--(Body)======================================================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<p class="NDLRefHeadClassTitle">efd::StreamMessage</p>
<p class="NDLRefParentage">: public <span class="NDLSystemFont"><a href="efd__IMessage.htm">efd::IMessage</a></span></p>


<p class="NDLRefHeaderFile">&lt;StreamMessage.h&gt;</p>

<p class="NDLRefHead1" style="text-align: center; ">
<div class="FigureContainer">
  <img src="./images/classefd_1_1_stream_message.gif" alt="Inheritance graph for efd::StreamMessage"/>
  <p class="FigureCaption">Inheritance graph for efd::StreamMessage</p>
</div>
</p>

<p class="NDLRefHead1">Description</p>
<p class="NDLNormal">A message class that can be used for fast prototyping. </p>
<p class="NDLNormal"><span class="NDLSystemFont">StreamMessage</span> can be used to quickly prototype messages without the need to create a custom message type and implement Serialize. The drawback to this is that an implementation detail of what order and what the data is stored in the message must be known everywhere the message is sent and received.</p>
<p class="NDLNormal">
<p class="NDLNormal">This class has been replaced by ParameterMessage which offers the addition of named parameters, random access of parameters, and type safe parameters. Consider upgrading from <span class="NDLSystemFont">StreamMessage</span> to ParameterMessage. </p></p>

<a name="public_methods"></a>
<p class="NDLRefHead1">Public Methods</p>


<a name="classefd_1_1_stream_message_1a22ec5fa48d204c79dd2881fff61890ca"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="efd__Archive.htm">efd::Archive</a></span>&  GetArchive()</p>
<p class="NDLRefMemberDescription">Access the archive inside the message. </p>

<a name="classefd_1_1_stream_message_1a760ad54981ac1c17235093cc988ab9fd"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="efd__Archive.htm">efd::Archive</a></span>&  GetArchive() const</p>
<p class="NDLRefMemberDescription">Access the archive inside the message. </p>

<a name="classefd_1_1_stream_message_1ab3897994f97b8ae4a2878db4bf65856a"></a>
<p class="NDLRefMemberFunction">StreamMessage()</p>
<p class="NDLRefMemberDetailedDescription">Creates an archive in packing mode </p>

<a name="classefd_1_1_stream_message_1a8501fa8d9b7f2985b5a45c6377a8c809"></a>
<p class="NDLRefMemberFunction">virtual ~StreamMessage()</p>
<p class="NDLRefMemberDescription">Virtual destructor. </p>

<a name="classefd_1_1_stream_message_1aa058df11809f08764428b857fc02256f"></a>
<p class="NDLRefMemberFunction">template &lt;typename T  &gt; <span class="NDLSystemFont">StreamMessage</span>&  operator&lt;&lt;(const T& data)</p>
<p class="NDLRefMemberDescription">Pack data into the message, message must be in packing mode. </p>

<a name="classefd_1_1_stream_message_1a91672fb80676a1d71d4db748197d975f"></a>
<p class="NDLRefMemberFunction">template &lt;typename T  &gt; const <span class="NDLSystemFont">StreamMessage</span>&  operator&gt;&gt;(T& data) const</p>
<p class="NDLRefMemberDescription">Read data from the message, message must be in unpacking mode. </p>

<a name="classefd_1_1_stream_message_1ad26e681d9276055d4362ef9d9c79b1f1"></a>
<p class="NDLRefMemberFunction">void  ResetForUnpacking() const</p>
<p class="NDLRefMemberDescription">Resets the archive to the beginning and converts the archive to Unpacking mode if needed. </p>

<a name="classefd_1_1_stream_message_1a2c94d94a617953206b5ddf9f22adbc04"></a>
<p class="NDLRefMemberFunction">virtual void  Serialize(<span class="NDLSystemFont"><a href="efd__Archive.htm">efd::Archive</a></span>& io_ar)</p>
<p class="NDLRefMemberDescription">Serialize a polymorphic type to or from an <span class="NDLSystemFont"><a href="efd__Archive.htm">Archive</a></span>. </p>
<p class="NDLRefMemberDetailedDescription">This method must be overridden, but if your streamable object has no data the override can be an empty function. A typical implementation of this method will make one call to <span class="NDLSystemFont"><a href="../Namespaces/efd__Serializer.htm#namespaceefd_1_1_serializer_1a63e0b99047011bde53be44786ab9ee7b">efd::Serializer::SerializeObject</a></span> for each member of the class. If you are derived from another streamable class you should be sure to call to parent implementation of this method as well; it is recommended that the parent class be serialized first before adding the data for the derived class. If your class contains complex data such as STL-style contianers or pointers to allocated data then you can simplify the implementation of Serialize by using the templated helper functions in &lt;<span class="NDLSystemFont">efd/SerializeRoutines.h</span>&gt;; these can serialize even the most complex data structures with a single method call and will reduce the chance of making common mistakes (which could introduce security vulnerabilities if marshalling data from untrusted sources).</p>
<p class="NDLRefMemberDetailedDescription"></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><span class="NDLSystemFont">io_ar</span></td>
    <td>The <span class="NDLSystemFont"><a href="efd__Archive.htm">Archive</a></span> to serialize to or from. </td>
</tr>

        </tbody>
    </table>
</div>



<a name="classefd_1_1_stream_message_1a193b583e5b6a35e8e3631eb0e8a072a3"></a>
<p class="NDLRefMemberFunction">void  SetBuffer(const <span class="NDLSystemFont"><a href="efd__SmartBuffer.htm">efd::SmartBuffer</a></span>& i_buffer)</p>
<p class="NDLRefMemberDescription">Sets the message to unpack from the given buffer. </p>
<p class="NDLRefMemberDetailedDescription">The buffer becomes shared between the caller and the <span class="NDLSystemFont"><a href="efd__Archive.htm">Archive</a></span> within this message. </p>

<a name="classefd_1_1_stream_message_1a133a37f4d9797c20730045ddeaec39f3"></a>
<p class="NDLRefMemberFunction"><span class="NDLSystemFont"><a href="../Namespaces/efd.htm#namespaceefd_1ac109bbf377c83566102d95319120db7b">efd::UInt32</a></span>  GetBufferSize() const</p>
<p class="NDLRefMemberDescription">Get the total number of bytes this stream uses. </p>
<p class="NDLRefMemberDetailedDescription">This count does not include padded space that is not yet allocated.</p>
<p class="NDLRefMemberDetailedDescription"></p>
<!--(Table)=====================================================================================-->
<div class="ReferenceTable">
    <table>
        <thead>
            <tr>
                <th>Parameter</th>
                <th>Description</th>
            </tr>
        </thead>
        <tbody>  
<tr>
    <td><em>Return Value</em></td>
    <td>Number of bytes used by this stream. </td>
</tr>

        </tbody>
    </table>
</div>


 
<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>
