<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>PhysX Tutorial - Kinematic Actors</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Build" content="PhysX" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script> <script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>


<h1>PhysX Tutorial - Kinematic Actors</h1>

<p>The aim of this portion of the Gamebryo-PhysX tutorial 
 is to show how animated objects are used to control physical actors. Such 
 actors are referred to as kinematic in the PhysX lexicon. They push other 
 objects around but are themselves unaffected by physics. The code extends 
 the <a HREF="PhysX_Tutorial_Ball_in_a_Box.htm">Ball-in-a-Box</a> tutorial. 
 When you start the application, you should see a paddle rotating in the 
 box, pushing the ball around. This tutorial also introduces debug geometry 
 rendering. </p>


<div class="NDLFigureContainer">
    <img src="./images/Kinematic_Screen.jpg" width="400" height="313" />
    <!-- <p class="NDLFigureCaption">{Figure caption}</p> -->
</div>

<h2>Enabling Kinematic Actors</h2>

<p>We load a different NIF file, this one containing the 
 animated paddle as well as the box. The paddle is a source for Gamebryo-PhysX: 
 an object that provides data to PhysX from the Gamebryo scene graph. In 
 this case the paddle animation is used to drive a kinematic actor. Like 
 destinations, sources must be enabled: </p>

<p><span class="NDLSystemFont">m_spPhysScene-&gt;SetUpdateSrc(true);</span></p>

<p>We are now ready to simulate. </p>

<h2>Run-Time Updating</h2>

<p>The scene now contains a source, so we must push the 
 state from Gamebryo's scene graph to the PhysX actor: </p>

<p><span class="NDLSystemFont">m_spPhysScene-&gt;UpdateSources(m_fAccumTime);</span></p>

<p>We make this call before <span class="NDLSystemFont">Simulate</span> 
 because the PhysX actor must be prepared before simulation begins. Otherwise, 
 the simulation and update proceeds as before. </p>

<h2>Debug Geometry</h2>

<p>PhysX is capable of producing geometry that shows the 
 current state of the simulation objects, which is extremely useful in 
 debugging. Gamebryo provides facilities to render this geometry. To turn 
 on debug rendering in Gamebryo, simply provide a scene graph node to which 
 the geometry should be attached: </p>

<p><span class="NDLSystemFont">m_spPhysScene-&gt;SetDebugRender(true, m_spScene);</span></p>

<p>You must also enable debug geometry production in PhysX: 
 </p>

<p><span class="NDLSystemFont">m_spPhysScene-&gt;m_pkPhysXSDK-&gt;setParameter(NX_VISUALIZATION_SCALE, 
 1.0f);</span></p>

<p>Exactly what is rendered is determined by settings in 
 the PhysX SDK object. Gamebryo will render whatever PhysX produces, although 
 this can have a significant impact on performance because the geometry 
 must be re-constructed on every frame. </p>

<h3>Next</h3>

<p>The <a href="PhysX_Tutorial_Asynchronous_Simulation.htm">Asynchronous 
 Simulation</a> tutorial is next.</p>

<h3><a HREF="PhysX_Tutorial_Ball_in_a_Box.htm">Previous</a></h3>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>
