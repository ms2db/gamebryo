<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
 "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>Rendering Meshes</title>
<!--(Begin Meta)===================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Pre-Expedition-RH" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)====================================================-->
    
<!--(Begin Links)===================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=====================================================-->

</head>

<!--(Begin Body)===================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script> <script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<h1>Rendering Meshes</h1>

<p>The following sections discuss the various methods that 
 can be used to render objects to a rendering target. All of the different 
 methods below assume that all prerequisites to rendering the object have 
 been met, such as an open frame, an active render target group, up-to-date 
 mesh data, and so on (see <a href="Rendering_a_Frame.htm">Rendering a Frame</a> for details). Any amount of <span class="NDLSystemFont"><a href="../../Reference/NiMain/NiRenderObject.htm">NiRenderObject</a></span> 
 objects can be rendered to an active render target (obviously, within 
 performance limits). Applications can mix and match all of the methods 
 described below <em>ad infinitum</em> to create the rendered scene they 
 desire.</p>

<p>Basic applications may not need to call any of these functions directly, but will instead use the rendering convenience functions 
 (for example, <span class="NDLSystemFont"><a href="../../Reference/NiMain/NiDrawSceneUtility.htm">NiDrawScene</a></span>) 
 and systems (for example, <span class="NDLSystemFont"><a href="../../Reference/NiApplication/Introduction_to_NiApplication.htm">NiApplication</a>::RenderFrame</span>), which call the rendering functions described below (as well as the previous step of culling) quite transparently.</p>

<h2>Basic Geometry Rendering</h2>

<p>At the lowest and most basic level, geometry can be 
 drawn to the renderer immediately via <span class="NDLSystemFont"><a href="../../Reference/NiMain/NiRenderObject.htm">NiRenderObject</a>::RenderImmediate(NiRenderer*)</span>. A visible renderable object can be drawn to the rendering target using the call as follows:</p>

<pre>
// Pointer is assumed to have been set to a valid geometry object.
NiRenderObject* pkObj;
// ...
 
pkObj-&gt;RenderImmediate(NiRenderer::GetRenderer());
</pre>


<p>An entire visible array (as generated by culling as 
 described in <a href="Culling_a_Scene_Graph.htm">Culling a Scene Graph</a>) 
 can be rendered as follows:</p>
 
<pre>
// Assumed to have been filled via culling or other process.
NiVisibleArray kVisibleSet;
// ...
 
const unsigned int uiQuantity = kVisibleSet.GetCount();
for (unsigned int i = 0; i &lt; uiQuantity; i++)
{
    kVisibleSet.GetAt(i).RenderImmediate(pkRenderer);
}
</pre> 

<p>In fact, the second code snippet is extremely similar to the low-level rendering code that comprises the non-sorted case of all of the <span 
 class="NDLSystemFont"><a href="../../Reference/NiMain/NiDrawSceneUtility.htm">NiDrawSceneUtility</a></span> functions. This code will render all of the objects in the given visible object array in the order that they were added to the array.</p>

<h2>Sorted Rendering with Accumulators</h2>

<p>While some applications can get away with rendering objects directly in the order in which they were added to the visible array, most Gamebryo applications use a more advanced form of rendering that allows for pre-processing of the renderable objects just prior to rendering. This pre-processing may be as simple as depth-sorting the objects and rendering them in back-to-front order, or may be more complex, such as collating the objects into several different categories and rendering each of these categories differently. See <a href="Object_Sorting.htm">Object Sorting</a> for an overview of the<a href="../../Reference/NiMain/NiAccumulator.htm"><span 
 class="NDLSystemFont">NiAccumulator</span></a>-based sorted rendering system 
 (as well as many details regarding the system).</p>

<h2>Screen-Space Geometry Rendering</h2>

<p>In addition to the various methods of rendering full, 3D scenes, Gamebryo includes the ability to render screen-relative meshes. These screen-space mesh objects are often used for user interface items, splash screens, heads-up displays, and so on. There are also useful when creating shader-based image-space tricks. See <a href="Screen_Space_Rendering.htm">Screen 
 Space Rendering</a> for a description of the methods for rendering screen-space meshes.</p>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>
