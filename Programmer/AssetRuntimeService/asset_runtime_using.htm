<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>Asset Tagging System Overview</title>
<!--(Begin Meta)================================================================================-->

<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="Originator" content="Expedition" />
<meta name="Generator" content="Palimpsest by Emergent Game Technologies - http://emergent.net" />
<meta name="Last-Updated" content="%lastupdated%" />

<!--(End Meta)==================================================================================-->
    
<!--(Begin Links)===============================================================================-->
    
<link rel="stylesheet" href="../../shared/Emergent.css" type="text/css" />

<!--(End Links)=================================================================================-->

</head>

<!--(Begin Body)================================================================================-->
<body lang="EN-US">
<script src="../../shared/NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
<script language="JavaScript1.2" type="text/javascript">WriteNavLink(2);</script>

<h1>Asset Tagging System Overview</h1>

<p>The basis of the Asset Runtime Service is its ability to apply tags to logical assets and asset
files in order to group them in ways that are independent of the chosen directory hierarchy in
which the files are stored. This provides an arbitrary level of logical organization that may or
may not be reflected directly in the hierarchy. Also, since any asset file can possess many tags it
makes it possible for a single file to appear in multiple organizational groupings. This solves the
problem of a filesystem hierarchy when an asset file actually belongs (based on usage) in multiple
groups but can only be in a single directory (without file duplication).</p>

<p>Consider a simple example where game assets are conveniently organized into sub-directories such
as "Levels", "Props", and "Characters". Some characters are used in multiple levels while others
are exclusive to one level. Also, some levels share some props, while other levels include unique
props. Additionally, there are platform specific versions of some assets and some assets are
localized for multiple languages. Even for this relatively mundane example, it is exceedingly
difficult to concoct a directory scheme that meets all the organizational requirements while making
it simple for the run-time to locate and load the right set of assets based on directory structure
alone. Even if such a scheme is achieved it would be difficult and error prone for content
developers to decide where to put new content files. Tagging goes a long way to solving this
dilemma by providing an additional organizational structure. For example, assets can be
appropriately tagged for "Level8", "Xbox360" and "Spanish" without specific limitations related to
where they are stored in the file system.</p>

<p>Asset tagging replaces ad-hoc mechanisms such as embedding tag-like information in an asset's
file name. Other creative anachronisms can be realized with asset tagging, but in a consistent
framework.</p>

<p>The <span class="NDLSystemFont">efd::AssetRuntimeService::AssetLocate</span> method is the main
way that a game identifies assets to load at run-time. This API allows you to pass in any
meaningful asset reference that has been defined by the system, and can include stacked tags to
identify a specific subset of assets. For example, the asset reference <span class=
"NDLSystemFont">urn:Level8:Spanish:Xbox360</span> would identify the set of assets that possess all
three specified tag values. In addition variant tags such as Xbox360 will fall back to
platform-neutral versions is the specific variant is not found. This gives good flexibility for
querying assets at run-time without being too closely coupled to the file system hierarchy that was
chosen.</p>

<p>The <span class="NDLSystemFont">efd::AssetRuntimeService::AssetLocate</span> method returns its
results by asynchronously sending a message of type AssetLocatorResponse. This message is populated
with a map of all the assets that matched the URI, and includes the asset Id, name, full path, and
the full set of tags that each asset possesses. In the case that there are no assets that match the
URI provided, you will still receive a response message, but the map of assets will contain zero
entries.</p>

<p class="NDLHeadingRelatedTopic">Related topics</p>

<ul>
    <li><a href="asset_runtime_organize_assets.htm">Organizing Your Assets</a></li>

    <li><a href="asset_runtime_config.htm">Configuring the Asset Runtime Service</a></li>

    <li><a href="asset_runtime_platform_support.htm">Supporting Multiple Platforms</a></li>

    <li><a href="asset_runtime_customize_asset_tagging_system.htm">Customizing the Asset Tagging
    System</a></li>

    <li><a href="asset_runtime_deploying_assets.htm">Deploying Assets</a></li>
</ul>

<!--kadov_tag{{<placeholder id="footer">}}-->

</body>

</html>
